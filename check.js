var btn = document.getElementById('submit');
btn.addEventListener('click', createCases);
var correctCasesBox = document.getElementById('correctCasesOutput');
var incorrectCasesBox = document.getElementById('incorrectCasesOutput');
const operators = ["+","-","*","/"];
var LIMIT = 20;

let data = {correctCasesMathJS: [], correctCasesMathOBJ: [], incorrectCasesMathJS: [], incorrectCasesMathOBJ: []}
function createCases(){
    correctCasesBox.value="";
    incorrectCasesBox.value="";
    
    numTestCases = document.getElementById("number").value;
    numCorrectCases = numTestCases/2;
    numIncorrectCases = numTestCases/2;
    generateCorrectCases(numCorrectCases);
    generateIncorrectCases(numIncorrectCases);
    
}

function generateCorrectCases(numCorrectCases) {
    var testsPassed = 0
    for (let index = 0; index < numCorrectCases; index++) {
        //Generate length of the expression
        lengthOfExpression = math.randomInt(2,10);
        for (let index = 0; index < lengthOfExpression; index++) {
            //Generates starting number
            randNum = math.randomInt(1, LIMIT);
            //Choses what sign (positive or negative) the first number will be. 16% chance that it will be negative
            //I chose 16% so that way not every single test case starts with or contains several negatives
            randSign = math.randomInt(6);
            if (randSign == 0) {
                //This is how to get pop operation in JS (Whose idea was it to skip the best stack operation....I see why devs don't like js now)
                var top = data.correctCasesMathJS[data.correctCasesMathJS.length-1];
                //We are going to push a negative number to the stack, check to see if the operator is subtraction if so replace subtraction with a plus (ie: 4--5 and 4-(-5) is the same as 4+5)
                //A negative minus a negative is a positive so why not make it evaluate it that way (also cause math obj has no idea how to do that)
                if(top == "-"){
                    data.correctCasesMathJS.pop();
                    data.correctCasesMathOBJ.pop();
                    data.correctCasesMathJS.push("+");
                    data.correctCasesMathOBJ.push("+");
                    data.correctCasesMathJS.push(randNum);
                    data.correctCasesMathOBJ.push(randNum);
                //If the operator is anything but subtraction it's safe to make the random number negative
                }else{
                    randNum *= -1;
                    data.correctCasesMathJS.push(randNum);
                    data.correctCasesMathOBJ.push(randNum);
                }
                
            } else {
                //Push the positive number on to the math.js stack
                data.correctCasesMathJS.push(randNum);
                data.correctCasesMathOBJ.push(randNum);
            }
    
            //Picks a random operator    
            getOperation(data.correctCasesMathJS, data.correctCasesMathOBJ);
            
            //Used for choosing trig operation or a number to follow the chosen operator
            randOperation = math.randomInt(4);
            if (randOperation == 0) {
                getTrigonometry(data.correctCasesMathJS, data.correctCasesMathOBJ);
                getOperation(data.correctCasesMathJS, data.correctCasesMathOBJ);
            }else{
                //Generates ending number and push to mathjs stack
                randNum = math.randomInt(1, LIMIT);
                data.correctCasesMathJS.push(randNum);
                data.correctCasesMathOBJ.push(randNum);
            }        
        }
        //Fixes trailing operator error (this is an error generated by my own fault)
        //This is ugly I know I'm not a fan of it myself but what can you do
        var top = data.correctCasesMathJS[data.correctCasesMathJS.length-1];
        if(top == "+" || top == "-" || top == "/" || top == "*"){
            randNum = math.randomInt(1, LIMIT);
            data.correctCasesMathJS.push(randNum);
            data.correctCasesMathOBJ.push(randNum);
        }

        //Take the stacks and combine them into their string form
        formulaStrMathJS = data.correctCasesMathJS.join('');
        formulaStrMathOBJ = data.correctCasesMathOBJ.join('');

        try {
            //Evaluate the strings using math.js and Math obj
            var resultMathJS = math.evaluate(formulaStrMathJS);
            var resultMathOBJ = eval(formulaStrMathOBJ);
            if (resultMathJS == resultMathOBJ) {
                //Output the generated test case to user
                //Add to textarea        show formula         solve the test case
                correctCasesBox.value += formulaStrMathJS + " = " + resultMathJS + " Test Passed" +'\n';
                testsPassed+=1;
                data.correctCasesMathJS = [];
                data.correctCasesMathOBJ = [];
            } else {
                //If the test case fails then it show test failed. If it fails it's because Math OBJ wrongly evaluated something
                correctCasesBox.value += formulaStrMathJS + " = " + resultMathJS + " Test Failed" +'\n';
                data.correctCasesMathJS = [];
                data.correctCasesMathOBJ = [];
            }
            
        } catch (error) {
            correctCasesBox.value += formulaStrMathJS + " = " + "Syntax error!" + '\n';           
            //Clear the stack
            data.correctCasesMathJS = [];
            data.correctCasesMathOBJ = [];
        }
    };
    console.log("Accuracy: " + (testsPassed/numCorrectCases)*100 +"%");
}

function generateIncorrectCases(numIncorrectCases) {
    var testsPassed = 0
    for (let index = 0; index < numIncorrectCases; index++) {
        //Generate length of the expression
        lengthOfExpression = math.randomInt(2,10);

        for (let index = 0; index < lengthOfExpression; index++) {
            randNum = math.randomInt(6);
            randSign = math.randomInt(6);
            getOperation(data.incorrectCasesMathJS, data.incorrectCasesMathOBJ);
            if (randSign == 0) {
                //Negate the random number
                randNum *= -1;
                data.incorrectCasesMathJS.push(randNum);
                data.incorrectCasesMathOBJ.push(randNum);
            } else {
                //Push the positive number on to the math.js stack
                data.incorrectCasesMathJS.push(randNum);
                data.incorrectCasesMathOBJ.push(randNum);
            }
            getOperation(data.incorrectCasesMathJS, data.incorrectCasesMathOBJ);
            randOperation = math.randomInt(4);
            if(randOperation == 0){
                getOperation(data.incorrectCasesMathJS, data.incorrectCasesMathOBJ);
            }else{
                randNum = math.randomInt(1, LIMIT);
                data.incorrectCasesMathJS.push(randNum);
                data.incorrectCasesMathOBJ.push(randNum);
                getOperation(data.incorrectCasesMathJS, data.incorrectCasesMathOBJ);
                getTrigonometry(data.incorrectCasesMathJS, data.incorrectCasesMathOBJ);
                
            }
            
        }
        //Take the stacks and combine them into their string form
        formulaStrMathJS = data.incorrectCasesMathJS.join('');
        formulaStrMathOBJ = data.incorrectCasesMathOBJ.join('');
        try{
            var resultMathJS = math.evaluate(formulaStrMathJS);
            var resultMathJS = math.evaluate(formulaStrMathOBJ);
            incorrectCasesBox.value += formulaStrMathJS + " = " + resultMathJS + " Test Failed" + '\n';
        } catch(error){
            incorrectCasesBox.value += formulaStrMathJS + " = " + " Test Passed" + '\n';           
            //Clear the stack
            data.incorrectCasesMathJS = [];
            data.incorrectCasesMathOBJ = [];
            testsPassed+=1;
        }
    }
    console.log("Accuracy: " + (testsPassed/numCorrectCases)*100 +"%");
}

function getOperation(mathJSStack, mathOBJStack) {
    //Picks a random operator
    randOperation = math.randomInt(4);
    if (randOperation == 0) {
        mathJSStack.push("+");
        mathOBJStack.push("+");
    }else if(randOperation == 1){
        mathJSStack.push("-");
        mathOBJStack.push("-");
    }else if(randOperation == 2){
        mathJSStack.push("*");
        mathOBJStack.push("*");
    }else if(randOperation == 3){
        mathJSStack.push("/");
        mathOBJStack.push("/");
    }
}

function getTrigonometry(mathJSStack, mathOBJStack){
    randOperation = math.randomInt(9);
    if(randOperation == 0) {
        //Cosine    
        mathJSStack.push("cos(");
        mathOBJStack.push("Math.cos(");
        randNum = math.randomInt(LIMIT);
        mathJSStack.push(randNum);
        mathOBJStack.push(randNum);
        mathJSStack.push(")");
        mathOBJStack.push(")");
    } else if(randOperation == 1) {
        //Sine
        mathJSStack.push("sin(");
        mathOBJStack.push("Math.sin(");
        randNum = math.randomInt(LIMIT);
        mathJSStack.push(randNum);
        mathOBJStack.push(randNum);
        mathJSStack.push(")");
        mathOBJStack.push(")");
    } else if (randOperation == 2) {
        //Tangent
        mathJSStack.push("tan(");
        mathOBJStack.push("Math.tan(");
        randNum = math.randomInt(LIMIT);
        mathJSStack.push(randNum);
        mathOBJStack.push(randNum);
        mathJSStack.push(")");
        mathOBJStack.push(")");
        
    } else if(randOperation == 3) {
        //Cotangent
        mathJSStack.push("cot(");
        mathOBJStack.push("cotangent(");
        randNum = math.randomInt(LIMIT);
        mathJSStack.push(randNum);
        mathOBJStack.push(randNum);
        mathJSStack.push(")");
        mathOBJStack.push(")");
    } else if(randOperation == 4) {
        //Arc-cosine
        mathJSStack.push("acos(");
        mathOBJStack.push("Math.acos(");
        randNum = math.random(1);
        mathJSStack.push(randNum);
        mathOBJStack.push(randNum);
        mathJSStack.push(")");
        mathOBJStack.push(")");
    } else if (randOperation == 5) {
        //Arc-sine
        mathJSStack.push("asin(");
        mathOBJStack.push("Math.asin(");
        randNum = math.random(1);
        mathJSStack.push(randNum);
        mathOBJStack.push(randNum);
        mathJSStack.push(")");
        mathOBJStack.push(")");
    } else if(randOperation == 6) {
        //Arc-tangent
        mathJSStack.push("atan(");
        mathOBJStack.push("Math.atan(");
        randNum = math.randomInt(1,LIMIT);
        mathJSStack.push(randNum);
        mathOBJStack.push(randNum);
        mathJSStack.push(")");
        mathOBJStack.push(")");
    } else if(randOperation == 7) {
        //Arc-cotangent
        mathJSStack.push("acot(");
        mathOBJStack.push("arcCotangent(");
        randNum = math.randomInt(LIMIT);
        mathJSStack.push(randNum);
        mathOBJStack.push(randNum);
        mathJSStack.push(")");
        mathOBJStack.push(")");
    } else if (randOperation == 8) {
        //Log
        mathJSStack.push("log(");
        mathOBJStack.push("Math.log(");
        randNum = math.randomInt(1,LIMIT);
        mathJSStack.push(randNum);
        mathOBJStack.push(randNum);
        mathJSStack.push(")");
        mathOBJStack.push(")");
    }
}

//Calculates arc-cotangent since the Math Object does not have one
function arcCotangent(angle){
    if (angle > 1) {
        return Math.atan(1/angle);
    }else if(angle < -1){
        return Math.PI + Math.atan(1/angle);
    }else{
        return Math.PI - Math.atan(angle);
    }  
}

//Calculates cotangent since the Math Object does not have one
function cotangent(angle){
    return 1/Math.tan(angle);
}